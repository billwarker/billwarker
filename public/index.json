[{"content":"Notes Types of ML\n  ML: algorithms learning from data and improving performance on a task\n  Advantage over rule based systems is that machine can update parameters/logic with new/more data (refreshing the model)\n  Applying ML to discover/understand patterns in the data: data mining\n  Supervised learning: training a model with labelled examples. can be used for classification tasks (predict a discrete category) or regression (predict a continuous number)\n  unsupervised learning algos: clustering unlabelled data, visualizing and dimensionality reduction, association rule learning\n  hierarchical clustering: sub-dividing clusters into smaller groups\n  dimensionality reduction: simplify data without losing too much information. i.e. merging correlated features. can help performance, takes up less disk and memory space\n  anomoly detection\n  association rule learning: relations between attributes (similar to data mining)\n  Semi-supervised learning. i.e. Google Photos, looks at unlabelled pictures to find common faces. once given a label for a person it can name everyone in the photo. mixed hierarchical models\n  Reinforcement learning: agent learns its environment and selects a policy (actions, strategy) to optimize some reward\n  Batch vs. Online Learning\n  Batch: training a model on all available data. train the system and then put it in prod. retrain new versions of the model with new data\n  requires a lot of computing resources, can be expensive. not suitable for autonomous systems with limited space for data (i.e. Mars rover)\n  Online: train system incrementally on mini-batches of data\n  great for continuous flows of data or limited storage resources\n  can be used to train on datasets that won\u0026rsquo;t fit in memory (out-of-core learning)\n  learning rate: how fast model adapts to new data\n  too high, forgets old data rapidly, too low, system has inertia (also less sensitive to noisey data)\n  need to monitor online systems if garbage data starts coming in\n  Instance-Based vs. Model-Based Learning\n  how a system generalizes (i.e. answers examples its never seen before)\n  Instance-based: generalizes to new examples by comparing similarity to training examples\n  i.e. KNN\n  Model-based: builds a model to predict new data\n  select a model (i.e. linear model) to represent the data\u0026rsquo;s pattern\n  tune model on a utility or cost function\n  if a model doesn\u0026rsquo;t generalize well, you can try again with better quality training data, more features, or a stronger model (e.g. polynomial vs. basic linear)\n  adding more data tends to get better results on all kinds of algos, to the point where performance can be identical with enough data\n  data needs to be representitive of the problem space trying to model, more data can eliminate noise but procedure needs to be solid or it risks sampling bias\n  Feature Engineering\n feature selection, picking the most useful features feature extraction, combining existing features to produce more useful ones + dimensionality reduction creating new features with the intro of new data  Performance\n  overfitting: performing well on the training data but not generalizing well\n  machine learning can pick up on noise in the data and sometimes even irrelevant features/useless metadata (i.e. data ids/index), detecting false patterns\n  overfitting happens when the model is too complex relative to the amount and noiseness of the data\n  regularization is constraining a model to make it simpler can help overfitting\n  controlled by model hyperparameters (knobs to tweak on the model itself, such as learning rate)\n  underfitting is opposite problem, model is too simple\n  fix it with a more complex model, more/better features, reducing regularization constraints\n  test models to see if they generalize well\n  split data into training and test sets to get error rate on new cases (out of sample/generalization error)\n  if training error is now but oos error is high, overfitting\n  use a third validation set to compare models/hyperparameters, then select the best one and use it one the test\n  cross validation splits the training set into subsets which are used for validation\n  need to make assumptions about the data to pick models reasonably\n  Questions How would you define ML?\n Algorithms that allow a computer to learn from data to improve on a task and generalize to new examples well  Four types of problems where it shines?\n Problems that traditionally require too many rules or hand-tuning Complex problems with no easy logic based model Problems where underlying strategy/solutions change over time, so new model can help adapt Data mining, learning underlying patterns in data  What is a labelled training set?\n Data that has the variable of interest classified (independent variable), and information about it in other attribures (dependent variables)  Two most common supervised tasks?\n Regression: predicting a continuous number for the target variable Classification: predicting a discrete category of target variable  Four kinds of unsupervised tasks?\n Clustering: creating groups in unstructured data Dimesionality Reduction: reducing the number of attributes in the training set while keeping most of the variance(underlying signal) Anomoly Dection: finding outliers Visualization Association Rule learning: data mining, learning patterns in the data  What type of ML algo would you use to allow a robot to walk in various unknown terrains?\n Reinforcement Learning  What type of algo would you use to segment your customers into multiple groups?\n Clustering, Unsupervised Learning  Would you frame the problem of spam detection as a supervised learning problem?\n Supervised; we can use examples of spam and ham (labelled training data) to create a model that identifies which is which  What is an online learning system?\n A system that can update with new data as it comes in, ingesting as it comes in through mini-batches  What is an out-of-core learning system?\n Using online learning to train the model on a dataset that wouldn\u0026rsquo;t fit inside the computers memory if you tried to train it in one giant batch.  What type of learning algo relies on similarity measures to make predictions?\n Instanced-based models, i.e. KNN  Difference between a model parameter and a hyperparameter?\n A model parameter is the coefficient determined by the algorithm to apply to a attribute/feature in the data when making predictions, a hyperparameter is an aspect of the model that you can adjust to change how it is trained  What do model-based learning algorithms search for? What is the most common strategy they use to succeed? How do they make predictions?\n These algo\u0026rsquo;s look to fit the model to the data (i.e. represent the problem with some simplified version of it). The strategy is to improve performance in respect to some cost/utility function. They make new predictions by applying the policy/parameters determined through training on the new data\u0026rsquo;s features  Four main challenges in ML?\n Not enough data Non-representative data Poor quality data Overfitting/Underfitting  If a model performs well on the training data but generalizes poorly to new examples, what is happening? 3 possible solutions?\n Model is overfitting to the training data and can\u0026rsquo;t generalize well to the new examples You can regularize the model (i.e. constrain it) to be less representative of the training data Train the model on more data/more representative data Tune the model on a validation set  What is a test set and why would you want to use it?\n Test the performance of the model on new examples to understand how well it generalizes to new data (i.e. the whole point)  What can go wrong if you tune hyperparameters on the test set?\n You fit the model to work well on the testing set, overfitting it and reducing the chance of generalizing well  What is cross validation, why is it better than a validation set?\n Cross validation takes different chunks of the training data and uses them iteratively to train and validate the model, creating a more robust model (training on different samples) and is a more economic use of data.  ","date":"2020-08-02","permalink":"https://billwarker.com/posts/handson-ml-ch1/","tags":["handson-ml","ml"],"title":"Hands on Machine Learning - Chapter 1 Notes"},{"content":"The Standard Error of the Mean The Standard Error of the Mean ($SE$) is the standard deviation of the sample distribution of the sample mean. To understand what this means, let\u0026rsquo;s break that sentence down in reverse order (i.e. chronologically):\nSample Mean: we have some probability density function $P$ for a population. We take a sample of $N$ instances from it and calculate our statistic of interest - in this case the mean, $\\bar{x}$. We have to take samples because it is hard/impossible to look at every instance in an entire population to calculate the true mean $\\mu$ hidden to us in nature (i.e. say we were interested in the average weight of all monkeys on the planet).\nSample Distribution: we take many samples (the number of which denoted by $M$) from the population\u0026rsquo;s probability density function $P$ and calculate the sample mean $\\bar{x}$ for each one. All of these sample means can be lumped together into a distribution $S$, which approximates a normal distribution the higher $M$ is due to the Central Limit Theorum. We want to create a sampling distribution because it allows us to reason about the likelihood of different values the sample mean can be. By doing so, we can look at the mean of this distribution and conclude that its the most likely value for $\\mu$ given the data we\u0026rsquo;ve used.\nStandard Deviation: The standard deviation is a metric that describes the dispersion of a dataset/distribution in relation to its mean. It speaks to how close/far the density of the distribution is spread in relation to its mean. The standard deviation of a sample distribution - our standard error $SE$ - is an indication of how representative the distribution is of our true mean $\\mu$. The smaller it is, the more representative it can be said to be; the larger it is, the harder it is to trust.\nTLDR: The Standard Error matters because it allows us to better understand how representative our sampling distribution is (i.e. our model of the true mean).\n$SE$ can be calculated with this formula:\n$$SE = \\frac{\\sigma}{\\sqrt{N}}$$\nwhere ${\\sigma}$ is the standard deviation of the population\u0026rsquo;s probability density function $P$ and $N$ is the number of instances in a sample.\nUnderstanding the Standard Error through Simulation import numpy as np import scipy as sp import pandas as pd import matplotlib.pyplot as plt  # create a random probability distribution function to model our population # in this case a Maxwell continuous random variable (picked randomly) x = np.linspace(sp.stats.maxwell.ppf(0.01), sp.stats.maxwell.ppf(0.99), 100) plt.plot(x, sp.stats.maxwell.pdf(x), 'b-', lw=5, alpha=0.6, label='maxwell pdf') plt.show() mean, var, skew, kurt = sp.stats.maxwell.stats(moments='mvsk') print(f'The true mean of the population is {mean} and its standard deviation is {var**(1/2)}')  The true mean of the population is 1.5957691216057308 and its standard deviation is 0.6734396116428514  # to create our sampling distribution S we take M samples of N instances each # we calculate the mean of each sample and add it to a list, which we can make a histogram with m_samples = 5000 n_instances = 250 sample_means = [] for m in range(m_samples): sample = sp.stats.maxwell.rvs(size=n_instances) # draw a sample from the population sample_means.append(sample.mean()) # add it to our sampling distribution sample_dist = pd.Series(sample_means) # our sample distribution as a pandas series  sample_dist.hist(bins=30) # visualizing our sample distribution of the sample mean  \u0026lt;matplotlib.axes._subplots.AxesSubplot at 0x1341e8fd0\u0026gt;  print(f\u0026quot;The mean of our sample distribution is {sample_dist.mean()}\u0026quot;) print(f\u0026quot;Its standard deviation (The Standard Error) is {sample_dist.std()}\u0026quot;)  The mean of our sample distribution is 1.5960355829136528 Its standard deviation (The Standard Error) is 0.04222284486122923  # calculating the same SE from the formula above se = np.sqrt(var)/np.sqrt(n_instances) print(f\u0026quot;The standard error calculated with the formula is: {se}\u0026quot;)  The standard error calculated with the formula is: 0.042592060787413163 ","date":"2020-07-12","permalink":"https://billwarker.com/posts/standard-error-of-the-mean/","tags":["stats"],"title":"The Standard Error of the Mean"},{"content":"Permutations of a Set Permutations of a set are particular orderings of its elements. To calculate the number of permutations (i.e. the possible orderings) of a subset $k$ distinct elements from a set of size $n$, the formula is:\n$$N(n, k) = \\frac{n!}{(n-k)!}$$\n$n!$ represents all orderings for every element in the set. $(n-k)!$ represents the orderings of the elements we\u0026rsquo;re not including in the subset of $k$ elements - dividing by this number allows us to factor them out of $n!$ in the numerator and give us the number of permutations.\nimport itertools import math S = ['A', 'B', 'C', 'D'] permutations = itertools.permutations(S, 2) # P(4,2) for p in permutations: print(p)  ('A', 'B') ('A', 'C') ('A', 'D') ('B', 'A') ('B', 'C') ('B', 'D') ('C', 'A') ('C', 'B') ('C', 'D') ('D', 'A') ('D', 'B') ('D', 'C')  def permutations(n, k): return int(math.factorial(n)/math.factorial(n-k)) permutations(4, 2)  12  Combinations of a Set Combinations don\u0026rsquo;t care about order - they are just the different subsets of elements in the set. To calculate the number of combinations (i.e. subsets) of $k$ distinct elements from a set of size $n$, the formula is:\n$$C(n, k) = \\frac{n!}{k!(n-k)!}$$\nAn easy way to understand combinations is in relation to permutations - basically, we are calculating the number of permutations of a subset created by $P(n, k)$ and then just dividing that number by the possible ways to order its elements (since combinations don\u0026rsquo;t care about that).\n$$C(n, k) = \\frac{P(n, k)}{k!} = \\frac{n!}{(n-k)!}*\\frac{1}{k!}$$\nS = ['A', 'B', 'C', 'D'] combinations = itertools.combinations(S, 2) # P(4,2) for c in combinations: print(c)  ('A', 'B') ('A', 'C') ('A', 'D') ('B', 'C') ('B', 'D') ('C', 'D')  def combinations(n, k): return int(permutations(n, k)/math.factorial(k)) combinations(4, 2)  6 ","date":"2020-07-07","permalink":"https://billwarker.com/posts/permutations-and-combinations/","tags":["stats"],"title":"Permutations and Combinations"}]